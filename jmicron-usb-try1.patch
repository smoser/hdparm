diff --git a/Makefile b/Makefile
index d28b703..44aaefb 100644
--- a/Makefile
+++ b/Makefile
@@ -22,7 +22,7 @@ INSTALL_DATA = $(INSTALL) -m 644
 INSTALL_DIR = $(INSTALL) -m 755 -d
 INSTALL_PROGRAM = $(INSTALL)
 
-OBJS = hdparm.o identify.o sgio.o sysfs.o geom.o fibmap.o fwdownload.o dvdspeed.o
+OBJS = hdparm.o identify.o sgio.o sysfs.o geom.o fibmap.o fwdownload.o dvdspeed.o apt.o
 
 all: hdparm
 
@@ -38,6 +38,8 @@ dvdspeed.o:     dvdspeed.c
 
 sgio.o: sgio.c sgio.h hdparm.h
 
+apt.o:		apt.c
+
 install: all hdparm.8
 	if [ ! -z $(DESTDIR) ]; then $(INSTALL_DIR) $(DESTDIR) ; fi
 	if [ ! -z $(DESTDIR)$(sbindir) ]; then $(INSTALL_DIR) $(DESTDIR)$(sbindir) ; fi
diff --git a/apt.c b/apt.c
new file mode 100644
index 0000000..afbb992
--- /dev/null
+++ b/apt.c
@@ -0,0 +1,334 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <linux/cdrom.h>
+#include <scsi/scsi.h>
+#include <scsi/sg.h>
+#include <sys/types.h>
+#include <errno.h>
+#include "hdparm.h"
+#include "sgio.h"
+
+/*
+ * apt - Support for ATA PASS THROUGH devices. Currently supported only
+ *       JMicron devices.
+ *
+ * Copyright (c) 2009	Jan Friesse <jfriesse@gmail.com>
+ *
+ * Magic numbers are taken from smartmontools source code
+ * (http://smartmontools.sourceforge.net/)
+ *
+ * You may use/distribute this freely, under the terms of either
+ * (your choice) the GNU General Public License version 2,
+ * or a BSD style license.
+ */
+
+#ifdef SG_IO
+
+/* External functions*/
+int sysfs_get_attr_recursive (int fd, const char *attr, const char *fmt, void *val1, void *val2, int verbose);
+
+/* Device initialization functions */
+static int apt_jmicron_int_init(int fd);
+
+/* Device sg16 functions*/
+static int apt_jmicron_sg16(int fd, int rw, int dma, struct ata_tf *tf,
+	    void *data, unsigned int data_bytes, unsigned int timeout_secs);
+
+/* Structs */
+struct apt_usb_id_entry {
+	int vendor_id;
+	int product_id;
+	int version;
+	const char *type;
+	int (*init_func)(int fd);
+	int (*sg16_func)(int fd, int rw, int dma, struct ata_tf *tf,
+	    void *data, unsigned int data_bytes, unsigned int timeout_secs);
+
+};
+
+struct apt_data_struct {
+	int is_apt;
+	struct apt_usb_id_entry id;
+	int verbose;
+	union {
+		struct {
+			int port;
+		} jmicron;
+	};
+};
+
+static struct apt_data_struct apt_data;
+
+const char apt_ds_jmicron[] = "jmicron";
+const char apt_ds_unsup[]   = "unsupported";
+
+const struct apt_usb_id_entry apt_usb_id_map[] = {
+	{0x152d, 0x2329, 0x0100, apt_ds_jmicron,
+	    apt_jmicron_int_init, apt_jmicron_sg16}, /* JMicron JM20329 (USB->SATA) */
+	{0x152d, 0x2336, 0x0100, apt_ds_jmicron,
+	    apt_jmicron_int_init, apt_jmicron_sg16}, /* JMicron JM20336 (USB+SATA->SATA, USB->2xSATA) */
+	{0x152d, 0x2338, 0x0100, apt_ds_jmicron,
+	    apt_jmicron_int_init, apt_jmicron_sg16}, /* JMicron JM20337/8 (USB->SATA+PATA, USB+SATA->PATA) */
+	{0x152d, 0x2339, 0x0100, apt_ds_jmicron,
+	    apt_jmicron_int_init, apt_jmicron_sg16}  /* JMicron JM20339 (USB->SATA) */
+};
+
+int apt_detect (int fd, int verbose)
+{
+	int err;
+	unsigned int i;
+
+	apt_data.is_apt = 0;
+
+	err = sysfs_get_attr_recursive(fd, "idVendor", "%x", &apt_data.id.vendor_id, NULL, verbose);
+	if (err) {
+		if (verbose) printf("APT: No idVendor found -> not USB bridge device\n");
+		return 0;
+	}
+
+	err = sysfs_get_attr_recursive(fd, "idProduct", "%x", &apt_data.id.product_id, NULL, verbose);
+	if (err) return 0;
+
+	err = sysfs_get_attr_recursive(fd, "bcdDevice", "%x", &apt_data.id.version, NULL, verbose);
+	if (err) return 0;
+
+	if (verbose)
+		printf("APT: USB ID = 0x%04x:0x%04x (0x%03x)\n", apt_data.id.vendor_id, apt_data.id.product_id,
+		  apt_data.id.version);
+
+	/* We have all needed informations, let's find if we support that device*/
+	for (i = 0; i <	sizeof(apt_usb_id_map)/sizeof(*apt_usb_id_map); i++) {
+		if (apt_data.id.vendor_id == apt_usb_id_map[i].vendor_id &&
+		    apt_data.id.product_id == apt_usb_id_map[i].product_id) {
+			/* Maybe two devices with same vendor and product id -> use version*/
+			if (apt_usb_id_map[i].version > 0 && apt_data.id.type &&
+			    apt_usb_id_map[i].version == apt_data.id.version) {
+				apt_data.id.type = apt_usb_id_map[i].type;
+				apt_data.id.init_func = apt_usb_id_map[i].init_func;
+				apt_data.id.sg16_func = apt_usb_id_map[i].sg16_func;
+			}
+
+			/* We don't have type -> set it (don't care about version) */
+			if (!apt_data.id.type) {
+				apt_data.id.type = apt_usb_id_map[i].type;
+				apt_data.id.init_func = apt_usb_id_map[i].init_func;
+				apt_data.id.sg16_func = apt_usb_id_map[i].sg16_func;
+			}
+		}
+	}
+
+	if (!apt_data.id.type || apt_data.id.type == apt_ds_unsup) {
+		if (verbose)
+			printf("APT: Unsupported device\n");
+
+		return 0;
+	}
+
+	apt_data.is_apt = 1;
+	if (verbose)
+		printf("APT: Found supported device %s\n", apt_data.id.type);
+
+	apt_data.verbose = verbose;
+
+	return (apt_data.id.init_func(fd));
+}
+
+int apt_is_apt (void)
+{
+	return apt_data.is_apt;
+}
+
+int apt_sg16(int fd, int rw, int dma, struct ata_tf *tf,
+	    void *data, unsigned int data_bytes, unsigned int timeout_secs)
+{
+	return apt_data.id.sg16_func(fd, rw, dma, tf, data, data_bytes, timeout_secs);
+}
+
+static void dump_bytes (const char *prefix, unsigned char *p, int len)
+{
+	int i;
+
+	if (prefix)
+		fprintf(stderr, "%s: ", prefix);
+	for (i = 0; i < len; ++i)
+		fprintf(stderr, " %02x", p[i]);
+	fprintf(stderr, "\n");
+}
+
+/***** JMicron support ********/
+static int apt_jmicron_int_sg(int fd, int rw, int dma, struct ata_tf *tf,
+        void *data, unsigned int data_bytes, unsigned int timeout_secs,
+        int port)
+{
+	unsigned char cdb[12];
+	struct scsi_sg_io_hdr io_hdr;
+
+	if (dma && apt_data.verbose)
+		printf("APT: JMicron doesn't support DMA\n");
+
+	if (tf->is_lba48) {
+		if (apt_data.verbose)
+			fprintf(stderr, "APT: JMicron doesn't support 48-bit ATA commands\n");
+                errno = EBADE;
+                return -1;
+	}
+
+	memset(&cdb, 0, sizeof(cdb));
+	memset(&io_hdr, 0, sizeof(struct scsi_sg_io_hdr));
+
+	// Build pass through command
+	cdb[ 0] = 0xdf;
+	cdb[ 1] = (rw ? 0x00 : 0x10);
+	cdb[ 2] = 0x00;
+	cdb[ 3] = (unsigned char)((data ? data_bytes : 0) >> 8);
+	cdb[ 4] = (unsigned char)((data ? data_bytes : 0) );
+	cdb[ 5] = tf->lob.feat;
+	cdb[ 6] = tf->lob.nsect;
+	cdb[ 7] = tf->lob.lbal;
+	cdb[ 8] = tf->lob.lbam;
+	cdb[ 9] = tf->lob.lbah;
+	cdb[10] = (port ? port : apt_data.jmicron.port);
+	cdb[11] =  tf->command;
+
+	io_hdr.interface_id	= 'S';
+	io_hdr.mx_sb_len	= 0;
+	io_hdr.dxfer_direction	= data ? (rw ? SG_DXFER_TO_DEV : SG_DXFER_FROM_DEV) : SG_DXFER_NONE;
+	io_hdr.dxfer_len	= data ? data_bytes : 0;
+	io_hdr.dxferp		= data;
+	io_hdr.cmdp		= cdb;
+	io_hdr.pack_id		= tf_to_lba(tf);
+	io_hdr.timeout		= (timeout_secs ? timeout_secs : 5) * 1000; /* msecs */
+	io_hdr.cmd_len 		= sizeof(cdb);
+
+	if (apt_data.verbose)
+		dump_bytes("outgoing cdb", cdb, sizeof(cdb));
+	if (ioctl(fd, SG_IO, &io_hdr) == -1) {
+		if (apt_data.verbose)
+			perror("ioctl(fd,SG_IO)");
+		return -1;      /* SG_IO not supported */
+        }
+	if (apt_data.verbose)
+		fprintf(stderr, "SG_IO: ATA_%u status=0x%x, host_status=0x%x, driver_status=0x%x\n",
+		    io_hdr.cmd_len, io_hdr.status, io_hdr.host_status, io_hdr.driver_status);
+
+	if (io_hdr.host_status || io_hdr.driver_status) {
+		errno = EBADE;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int apt_jmicron_int_get_registers(int fd, unsigned short addr,
+				    unsigned char * buf, unsigned short size)
+{
+	struct ata_tf tf;
+
+	memset(&tf, 0, sizeof(tf));
+
+	tf.lob.feat	= 0x00;
+	tf.lob.nsect	= (unsigned char)(addr >> 8);
+	tf.lob.lbal	= (unsigned char)(addr);
+	tf.lob.lbam	= 0x00;
+	tf.lob.lbah	= 0x00;
+	tf.command	= 0xfd;
+
+	return apt_jmicron_int_sg(fd, 0, 0, &tf, buf, (unsigned int)size, 0, 0x00);
+}
+
+static int apt_jmicron_int_init(int fd)
+{
+	unsigned char regbuf = 0;
+	int res;
+
+	if ((res = apt_jmicron_int_get_registers(fd, 0x720F, &regbuf, 1)) == -1) {
+		return res;
+	}
+
+	if (regbuf & 0x04) {
+		apt_data.jmicron.port = 0xa0;
+	} else if (regbuf & 0x40) {
+		apt_data.jmicron.port = 0xb0;
+	} else {
+		perror("APT: No JMicron device connected");
+		errno = ENODEV;
+		return -1;
+	}
+
+	if (apt_data.verbose)
+		printf("APT: JMicron Port: 0x%X\n", apt_data.jmicron.port);
+	return 0;
+}
+
+static int apt_jmicron_sg16(int fd, int rw, int dma, struct ata_tf *tf,
+        void *data, unsigned int data_bytes, unsigned int timeout_secs)
+{
+	int res;
+	unsigned char regs[16];
+
+	memset(regs, 0, sizeof(tf));
+
+	res = apt_jmicron_int_sg(fd, rw, dma, tf, data, data_bytes, timeout_secs, 0);
+
+	if (res == -1) return res;
+
+	if ((res = apt_jmicron_int_get_registers(fd,
+	    (apt_data.jmicron.port == 0xa0 ? 0x8000 : 0x9000), regs, sizeof(regs))) == -1) {
+		return res;
+	}
+
+	tf->is_lba48  = 0;
+	tf->error     = regs[13];
+	tf->lob.nsect = regs[ 0];
+	tf->lob.lbal  = regs[ 6];
+	tf->lob.lbam  = regs[ 4];
+	tf->lob.lbah  = regs[10];
+	tf->dev       = regs[ 9];
+	tf->status    = regs[14];
+	tf->hob.feat  = 0;
+	tf->hob.nsect = 0;
+	tf->hob.lbal  = 0;
+	tf->hob.lbam  = 0;
+	tf->hob.lbah  = 0;
+
+	if (apt_data.verbose)
+		fprintf(stderr, "      ATA_%u stat=%02x err=%02x nsect=%02x lbal=%02x lbam=%02x lbah=%02x dev=%02x\n",
+				12, tf->status, tf->error, tf->lob.nsect, tf->lob.lbal, tf->lob.lbam, tf->lob.lbah, tf->dev);
+
+	if (tf->status & (ATA_STAT_ERR | ATA_STAT_DRQ)) {
+		if (apt_data.verbose) {
+			fprintf(stderr, "I/O error, ata_op=0x%02x ata_status=0x%02x ata_error=0x%02x\n",
+				tf->command, tf->status, tf->error);
+		}
+		errno = EIO;
+		return -1;
+	}
+	return 0;
+}
+
+#else
+/* No SGIO -> no support*/
+int apt_detect (int fd, int verbose)
+{
+	if (verbose)
+		printf("APT: SGIO Support needed for fd %d\n", fd);
+	return 0;
+}
+
+int apt_is_apt (void)
+{
+	return 0;
+}
+
+int apt_sg16(int fd, int rw, int dma, struct ata_tf *tf,
+	    void *data, unsigned int data_bytes, unsigned int timeout_secs)
+{
+	printf("APT: SG16 fd %d rw %d dma %d tf %p data %p data_bytes %d timeout %d need SGIO\n",
+		fd, rw, dma, tf, data, data_bytes, timeout_secs);
+	return -1;
+}
+#endif
diff --git a/hdparm.c b/hdparm.c
index f18ec6e..55d75bc 100644
--- a/hdparm.c
+++ b/hdparm.c
@@ -1194,6 +1194,13 @@ void process_dev (char *devname)
 	if (!quiet)
 		printf("\n%s:\n", devname);
 
+	if (apt_detect(fd, verbose) == -1) {
+		err = errno;
+		perror(devname);
+		close(fd);
+		exit(err);
+	}
+
 	if (set_fsreadahead) {
 		if (get_fsreadahead)
 			printf(" setting fs readahead to %d\n", fsreadahead);
diff --git a/hdparm.h b/hdparm.h
index 60a0045..0f38b16 100644
--- a/hdparm.h
+++ b/hdparm.h
@@ -21,6 +21,10 @@ int fwdownload(int fd, __u16 *id, const char *fwpath);
 void dco_identify_print (__u16 *dco);
 int set_dvdspeed(int fd, int speed);
 
+/* APT Functions */
+int apt_detect (int fd, int verbose);
+int apt_is_apt (void);
+
 extern const char *BuffType[4];
 
 struct local_hd_big_geometry {
diff --git a/sgio.c b/sgio.c
index e3de83e..18f3926 100644
--- a/sgio.c
+++ b/sgio.c
@@ -148,6 +148,10 @@ int sg16 (int fd, int rw, int dma, struct ata_tf *tf,
 	unsigned char sb[32], *desc;
 	struct scsi_sg_io_hdr io_hdr;
 
+	if (apt_is_apt()) {
+		return apt_sg16(fd, rw, dma, tf, data, data_bytes, timeout_secs);
+	}
+
 	memset(&cdb, 0, sizeof(cdb));
 	memset(&sb,     0, sizeof(sb));
 	memset(&io_hdr, 0, sizeof(struct scsi_sg_io_hdr));
diff --git a/sgio.h b/sgio.h
index 7ad2d11..155c4d8 100644
--- a/sgio.h
+++ b/sgio.h
@@ -228,3 +228,7 @@ int do_taskfile_cmd (int fd, struct hdio_taskfile *r, unsigned int timeout_secs)
 int dev_has_sgio (int fd);
 void init_hdio_taskfile (struct hdio_taskfile *r, __u8 ata_op, int rw, int force_lba48,
 				__u64 lba, unsigned int nsect, int data_bytes);
+
+/* APT */
+int apt_sg16(int fd, int rw, int dma, struct ata_tf *tf,
+		void *data, unsigned int data_bytes, unsigned int timeout_secs);
diff --git a/sysfs.c b/sysfs.c
index d21e678..fd51d5c 100644
--- a/sysfs.c
+++ b/sysfs.c
@@ -194,3 +194,64 @@ int sysfs_set_attr (int fd, const char *attr, const char *fmt, void *val_p, int
 		err = sysfs_write_attr(path, attr, fmt, val_p, verbose);
 	return err;
 }
+
+static int sysfs_find_attr_file_path (const char *start_path, char **dest_path, const char *attr)
+{
+	static char path[PATH_MAX];
+	static char have_prev = 0;
+	char file_path[PATH_MAX + FILENAME_MAX];
+	struct stat st;
+	ino_t stop_inode;
+	int depth = 0;
+
+	if (have_prev) {
+		*dest_path = path;
+
+		return 0;
+	}
+
+	stat("/sys/devices", &st);
+	stop_inode = st.st_ino;
+
+	strcpy(path, start_path);
+
+	while (depth < 20) {
+		strcat(path, "/..");
+
+		if (stat(path, &st) != 0)
+			return errno;
+
+		if (st.st_ino == stop_inode)
+			return EINVAL;
+
+		strcpy(file_path, path);
+		strcat(file_path, "/");
+		strcat(file_path, attr);
+
+		if (access(file_path, F_OK | R_OK) == 0) {
+			*dest_path = path;
+
+			return 0;
+		}
+	}
+
+	return EINVAL;
+}
+
+int sysfs_get_attr_recursive (int fd, const char *attr, const char *fmt, void *val1, void *val2, int verbose)
+{
+	char *path;
+	char *attr_path;
+	int err;
+
+	err = sysfs_find_fd(fd, &path, verbose);
+	if (!err) {
+		err = sysfs_find_attr_file_path(path, &attr_path, attr);
+
+		if (!err) {
+			err = sysfs_read_attr(attr_path, attr, fmt, val1, val2, verbose);
+		}
+	}
+
+	return err;
+}
